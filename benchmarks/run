#!/usr/bin/perl

#use local::lib;
my $USERHOME = $ENV{HOME};
my $USERREPO = "$USERHOME/dynamiteLTL";
my $TOOLSDIR = '/tools';

$ENV{"CONDA_HOME"} = "/tools/miniconda3/bin/python3";
$ENV{"DIG_HOME"} ="/tools/dig/src/dig.py";

###############################################################
use strict;
use warnings;
use File::Temp qw(tempfile tempdir);
use Time::Out qw(timeout) ;
use Time::HiRes qw(gettimeofday tv_interval);

my $ITERS = 1;
my $TIMEOUT  = 300;
my $INTEGRATED = 0;
my @timedout;
my $pid = getppid();
my $PROPERTY;
my $HARVEST = 0;
my $TMPFILE = "/tmp/dynamo.$pid.txt";
my $KILL = "killall java; killall z3;";
my $HARD_TIMEOUT = 0; # hard force timeout
###############################################################
sub specfile {
    return qq{$USERREPO/benchmarks/termination.prp} if $_[0] eq 'termination';
    return qq{$USERREPO/benchmarks/nontermination.prp} if $_[0] eq 'nontermination';
    die "specfile - $_[0]";
}
###############################################################
use lib '.';
use Parsers qw{ult ultreach dynamo dynamltl};

my $t0;
my $CFG = {
    # dynamo => {
    #     DIR => qq{$DYNAMITE_HOME/src},
    #     CMD => sub { my $arg = ($SPECFILE_TERM =~ m/\/term/ ? '-t' : '-nt');
	# 	     $arg = '' if $INTEGRATED == 1;
    #                  $t0 = [gettimeofday];
    #                  return qq($KILL python3 dynamo.py --timeout=$TIMEOUT $_[0] $arg 2>\&1 | tee $TMPFILE);
    #     },
    #     FETCH => sub { my $elapsed = tv_interval($t0);
	# 	       my $tm = "HARD TIMER: $elapsed\n";
	# 	       open TM, ">>$TMPFILE" or warn $!;
	# 	       print TM "\n$tm\n";
	# 	       close TM;
	# 	       return qq(cp $TMPFILE $_[0]); },
    #     PARSE => sub { return Parsers::dynamo($_[0]); },
    # },
    dynamltl => {
        DIR    => qq{$USERREPO/src},
        CMD => sub { return qq(./dynamltl.py --inp  $_[0] 2>&1 > dynamltl.log); },
        FETCH  => sub { return qq(cp dynamltl.log $_[0]); },
        PARSE  => sub { return Parsers::dynamltl($_[0]); },
    },
    ultimate => {
        DIR    => qq{$USERREPO/bin},
#        CMD    => sub { return qq($KILL timeout ${TIMEOUT}s ./Ultimate.py --file $_[0]  --spec $SPECFILE --architecture 32bit); },
        CMD => sub { return qq(./ultimate-ltl-nla $_[0] 2>&1 > Ultimate.log); },
        FETCH  => sub { return qq(cp Ultimate.log $_[0]); },
        PARSE  => sub { return Parsers::ult($_[0]); },
    },
    ultimatereach => {
        DIR    => qq{$USERREPO/bin},
#        CMD    => sub { return qq($KILL timeout ${TIMEOUT}s ./Ultimate.py --file $_[0]  --spec $SPECFILE --architecture 32bit); },
        CMD => sub { return qq(./ultimate-reach-lin $_[0] 2>&1 > Ultimate.log); },
        FETCH  => sub { return qq(cp Ultimate.log $_[0]); },
        PARSE  => sub { return Parsers::ultreach($_[0]); },
    },
    aprove => {
        DIR    => qq{$TOOLSDIR/aprove},
        CMD    => sub { return qq(./AProVE.sh $_[0] > aprove.log); },
        FETCH  => sub { return qq(cp aprove.log $_[0]); },
        PARSE  => sub { return Parsers::aprove($_[0]); }
    },
    seahorn => {
        DIR    => qq{$TOOLSDIR/seahorn/build/run/bin},
        CMD    => sub { my $specf = specfile('termination');
                        return qq($TOOLSDIR/seahorn/build/run/bin/sea_svcomp --cpu=10 --cex=error-witness.graphml -m64 --spec=$specf $_[0] > /tmp/seahorn.log); },
        FETCH  => sub { return qq(mv /tmp/seahorn.log $_[0]); },
        PARSE  => sub { return Parsers::seahorn($_[0]); }
    }
};
    
###############################################################
#### Utilities
sub runc { my ($cmd) = @_; print "+ $cmd\n(with timeout of $TIMEOUT s)\n";
	   if ($HARD_TIMEOUT == 1) {
	       timeout $TIMEOUT => sub { print qx{$cmd}; };
	       if ($@) {  push @timedout, $cmd; }
	   } else {
	       print qx{$cmd};
	   }
}	   

###############################################################
#### Arguments parsing
die "usage: ./run (options) <subdir> (list|run) [dynamo,ultimate,seahorn,aprove] (geo1-both-t,cohencu2-both-t,...)\n".
    "  (last argument is optional) \n".
    "  options:\n".
    "    --prop=(t|nt|ltl) # default is \"t\" for termination\n".
    "    --iters=1\n".
    "    --harvest=true    # after benchmarks are run, harvest results\n".
    "    --integrated=1    # for integrated\n".
    "    --hardtimeout=1   # hard force timeout\n".
    "    --timeout=900\n" unless $#ARGV >= 1;
while ($ARGV[0] =~ /^--(.*)=(.+)$/) {
    my ($k,$v) = ($1,$2);
    shift @ARGV;
    $TIMEOUT = $v if $k eq 'timeout';
    $INTEGRATED = 1 if $k eq 'integrated';
    $HARD_TIMEOUT = 1 if $k eq 'hardtimeout';
    $HARVEST = 1 if $k eq 'harvest';
    $PROPERTY = 'termination'    if $k eq 'prop' && $v =~ /^t/;
    $PROPERTY = 'nontermination' if $k eq 'prop' && $v =~ /^non/;
    $PROPERTY = 'ltl'            if $k eq 'prop' && $v =~ /^ltl/;
    $ITERS = $v if $k eq 'iters';
}
my @bnames = ();
my ($bdir,$arg1,$ts,$bms) = @ARGV;
my @tools = split ',', $ts;
@bnames = split ',', $bms if defined $bms;
use Data::Dumper;
print "*\n";
print "* Benchmarking\n";
print "*\n";
print "* Paper: Dynamic LTL\n";
print "* Authors: (omitted for blind)\n";
print "*\n";
print "* Configuration:\n";
print "    Filter to   : ".join(' ',@bnames)."\n" if $#bnames >= 0;
print "    Tools       : $ts\n";

use Parsers qw/find_benchmarks/;
my ($benchdir,$benchesref,$b2expected) = Parsers::find_benchmarks($bdir,\@bnames);
my @benches = sort @{$benchesref}; # [50..158];
print "    Total files : ".($#benches+1)."\n";
exit if ($arg1 eq 'list');

chdir $benchdir;

################### Running the benchmarks
if ($arg1 eq 'run') {
    my $tmpl = ($INTEGRATED == 1 ? "integrated-XXXXXXX" : "out-XXXXXXX");
    my $t = File::Temp->newdir( $tmpl, CLEANUP => 0 );
    my $outdir = $t->dirname;
    print "*   Saving logs to: $benchdir/$outdir\n";
    open TMP, ">/tmp/dynamite.outdir" or die $!;
    print TMP $outdir;
    close TMP;
    print "*\n*\n";
    my $ct = 0;
    foreach my $tool (@tools) {
        my %b2res;
        foreach my $b (@benches) {
            print "* --- Now executing DynamiTe on benchmark: $b ---\n";
            for my $iter (1..$ITERS) {
                chdir $CFG->{$tool}->{DIR} or die "can't CHDIR to $CFG->{$tool}->{DIR}: $!";
                #my $SPECFILE = ($b =~ m/-nt\./ ? $NT_SPECFILE : $T_SPECFILE);
                runc( $CFG->{$tool}->{CMD}->("$benchdir/$b") );
                my $logfn = "$benchdir/$outdir/$tool-$b.log.$iter";
                runc( $CFG->{$tool}->{FETCH}->($logfn) );
                #$b2res{$b} = $CFG->{$tool}->{PARSE}->($logfn);
                #print "$logfn - Time:$b2res{$b}->{time} - Result:$b2res{$b}->{result}\n";
            }
        }
    }
    my $ts = join ',', @tools;
    my $hcmd = qq(./harvest --iters=1 --tools=$ts nocsvs $bdir/$outdir);
    print "*\n* you may now harvest the results:\n $hcmd\n*\n";
    print "Timedout:  \n".join("\n   ",@timedout)."\n" if $#timedout >= 0;
    if ($HARVEST == 1 ){
        chdir "$USERREPO/benchmarks";
        print qx($hcmd);
    }
}

