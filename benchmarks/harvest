#!/usr/bin/perl

use strict;
use warnings;
use Data::Dumper;
use lib '.';
my @tools = qw/ultimatereach dynamltl/; #dynamo ultimate aprove seahorn/;
use Parsers qw{parse find_benchmarks};

################### Arguments
my $COMPARISON = 0; my $ITERS = 1; my $PROVETNT = 0;
my $usage = "usage: ./harvest [options] (csvs|nocsvs) <benchdir>/<tmpdir>\n".
    "  where options are: --iters=5 --compare=1 --integrated=1 --tools=dynamltl,ultimate\n";
die $usage unless $#ARGV >= 1;
while ($ARGV[0] =~ /^--(.*)=(.+)$/) {
    my ($k,$v) = ($1,$2);
    shift @ARGV;
    @tools = split ",", $v if $k eq 'tools';
    $COMPARISON = 1 if $k eq 'compare';
    $ITERS = $v if $k eq 'iters';
    $PROVETNT = 1 if $k eq 'integrated'
}
my ($csvs,$a3) = @ARGV;
my ($bdir,$outdir) = split '/', $a3 or die $!;

#########################################################

print "*\n";
print "* Benchmarking -- Harvest Results\n";
print "*\n";
print "* Paper: Dynamite LTL\n";
print "* Authors: (omitted for blind)\n";
print "*\n";
print "* Configuration:\n";

my @bnames = ();
my ($benchdir,$benchesref,$b2expected) = Parsers::find_benchmarks($bdir,\@bnames);
my @benches = @{$benchesref};
print "*\n\n";

################### Filename for results
use POSIX qw(strftime);
my $now = time();
my $fn = strftime('%Y%m%d%H%M%S', gmtime($now));

my @integrated;
my @integratedHtml;
my @integratedC;
my @integratedCHtml;
my @dynDetail;
my @dynHtml;
my @skips;
################### Harvesting the results
my @newfile;
my $compare;

foreach my $tool (@tools) {
  foreach my $b (sort @benches) {
      mkdir("../results/$b") if (not (-e "../results/$b"));
      my $logfn = "$benchdir/$outdir/$tool-$b.log.1"; 
      die "could not find: $logfn" unless -f $logfn;
      #if (not (-e $logfn.".1")) { push @skips, $logfn; next; }
      my $tmpb = $b; #$tmpb =~ s/-both-n?t.c//;
      # Step 1: General parsing that all tools/variants support
      #$compare->{$tmpb}->{$tool} = 
      my $d = Parsers::parse($tool,$logfn,$ITERS);
      my $bb = $tmpb; $bb =~ s/_lia//;
      if($tmpb =~ /\_lia/) {
        $compare->{$bb}->{$tool}->{liatime} = $d->{time};
        $compare->{$bb}->{$tool}->{liaresult} = $d->{result};
      } else {
        $compare->{$bb}->{$tool}->{nlatime} = $d->{time};
        $compare->{$bb}->{$tool}->{nlaresult} = $d->{result};
      }
     # print Dumper($compare);
  }
}

#
# Generate LaTeX
#
print "\n% RESULTS:\nBenchmark & Exp. & ".
   join(" & ", map("$_ Res & $_ Time & $_ Summary",@tools))."\\\\\n\\hline\n";
foreach my $b (sort keys %$compare) {
  my $exp = '\rTRUE'; $exp = '\rFALSE' if $b =~ /invalid/;
  printf("%-15s & %-8s & ", $b, $exp);
  foreach my $tool (@tools) {
    my $liaeek = ( $compare->{$b}->{$tool}->{liaresult} eq $exp ? '' : '!!!');
    my $nlaeek = ( $compare->{$b}->{$tool}->{nlaresult} eq $exp ? '' : '!!!');
    printf("& %-8s$nlaeek & %-8s & %-8s$liaeek & %-8s ",
    $compare->{$b}->{$tool}->{nlaresult},
    $compare->{$b}->{$tool}->{nlatime} ,
    $compare->{$b}->{$tool}->{liaresult},
    $compare->{$b}->{$tool}->{liatime});
  }
  print " \\\\\n";
}