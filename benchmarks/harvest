#!/usr/bin/perl

use strict;
use warnings;
use Data::Dumper;
use lib '.';
my @tools = qw/ultimatereach dynamltl/; #dynamo ultimate aprove seahorn/;
use Parsers qw{parse find_benchmarks};

################### Arguments
my $COMPARISON = 0; my $ITERS = 1; my $PROVETNT = 0;
my $usage = "usage: ./harvest [options] (csvs|nocsvs) <benchdir>/<tmpdir>\n".
    "  where options are: --iters=5 --compare=1 --integrated=1 --tools=dynamltl,ultimate\n";
die $usage unless $#ARGV >= 1;
while ($ARGV[0] =~ /^--(.*)=(.+)$/) {
    my ($k,$v) = ($1,$2);
    shift @ARGV;
    @tools = split ",", $v if $k eq 'tools';
    $COMPARISON = 1 if $k eq 'compare';
    $ITERS = $v if $k eq 'iters';
    $PROVETNT = 1 if $k eq 'integrated'
}
my ($csvs,$a3) = @ARGV;
my ($bdir,$outdir) = split '/', $a3 or die $!;

#########################################################

print "*\n";
print "* Benchmarking -- Harvest Results\n";
print "*\n";
print "* Paper: Dynamite LTL\n";
print "* Authors: (omitted for blind)\n";
print "*\n";
print "* Configuration:\n";

my @bnames = ();
my ($benchdir,$benchesref,$b2expected) = Parsers::find_benchmarks($bdir,\@bnames);
my @benches = @{$benchesref};
print "*\n\n";

################### Filename for results
use POSIX qw(strftime);
my $now = time();
my $fn = strftime('%Y%m%d%H%M%S', gmtime($now));

my @integrated;
my @integratedHtml;
my @integratedC;
my @integratedCHtml;
my @dynDetail;
my @dynHtml;
my @skips;
################### Harvesting the results
my @newfile;
my $compare;

foreach my $tool (@tools) {
  foreach my $b (sort @benches) {
      mkdir("../results/$b") if (not (-e "../results/$b"));
      my $logfn = "$benchdir/$outdir/$tool-$b.log.1"; 
      die "could not find: $logfn" unless -f $logfn;
      #if (not (-e $logfn.".1")) { push @skips, $logfn; next; }
      my $tmpb = $b; #$tmpb =~ s/-both-n?t.c//;
      # Step 1: General parsing that all tools/variants support
      $compare->{$tmpb}->{$tool} = Parsers::parse($tool,$logfn,$ITERS);
     # print Dumper($compare);
  }
}

#
# Generate LaTeX
#
print "\n% RESULTS:\nBenchmark & ".
   join(" & ", map("$_ Res & $_ Time & $_ Summary",@tools))."\\\\\n\\hline\n";
foreach my $b (sort keys %$compare) {
  printf("%-15s & ", $b);
  foreach my $tool (@tools) {
    printf("& %-8s & %-8s & %-40s",
    $compare->{$b}->{$tool}->{result},
    $compare->{$b}->{$tool}->{time} ,
    $compare->{$b}->{$tool}->{summary});
  }
  print " \\\\\n";
}